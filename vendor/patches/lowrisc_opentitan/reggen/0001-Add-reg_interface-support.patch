From 5ef20f6e50cc202026c951ec5807530b4de3b652 Mon Sep 17 00:00:00 2001
From: Michael Rogenmoser <michael@rogenmoser.us>
Date: Mon, 17 Jul 2023 17:17:38 +0200
Subject: [PATCH] Add reg_interface support

---
 bus_interfaces.py |  20 +++++++-
 fpv_csr.sv.tpl    |   5 ++
 reg_top.sv.tpl    | 117 ++++++++++++++++++++++++++++++++++++++++++----
 3 files changed, 132 insertions(+), 10 deletions(-)

diff --git a/bus_interfaces.py b/bus_interfaces.py
index fbeb99ca3..7c528d5f1 100644
--- a/bus_interfaces.py
+++ b/bus_interfaces.py
@@ -4,12 +4,22 @@
 
 '''Code representing a list of bus interfaces for a block'''
 
+from enum import Enum
 from typing import Dict, List, Optional, Tuple
 
 from reggen.inter_signal import InterSignal
 from reggen.lib import check_list, check_keys, check_str, check_optional_str
 
 
+class BusProtocol(Enum):
+    TLUL = "tlul"
+    REG_IFACE = "reg_iface"
+
+    @classmethod
+    def has_value(cls, v):
+        return v in cls._value2member_map_
+
+
 class BusInterfaces:
     def __init__(self,
                  has_unnamed_host: bool,
@@ -17,6 +27,7 @@ class BusInterfaces:
                  host_async: Dict[Optional[str], str],
                  has_unnamed_device: bool,
                  named_devices: List[str],
+                 interface_list: List[Dict],
                  device_async: Dict[Optional[str], str],
                  device_hier_paths: Dict[Optional[str], str]):
         assert has_unnamed_device or named_devices
@@ -28,6 +39,7 @@ class BusInterfaces:
         self.host_async = host_async
         self.has_unnamed_device = has_unnamed_device
         self.named_devices = named_devices
+        self.interface_list = interface_list
         self.device_async = device_async
         self.device_hier_paths = device_hier_paths
 
@@ -35,6 +47,7 @@ class BusInterfaces:
     def from_raw(raw: object, where: str) -> 'BusInterfaces':
         has_unnamed_host = False
         named_hosts = []
+        interface_list = []
         host_async = {}
 
         has_unnamed_device = False
@@ -50,7 +63,7 @@ class BusInterfaces:
 
             protocol = check_str(ed['protocol'],
                                  'protocol field of ' + entry_what)
-            if protocol != 'tlul':
+            if not BusProtocol.has_value(protocol):
                 raise ValueError('Unknown protocol {!r} at {}'
                                  .format(protocol, entry_what))
 
@@ -110,12 +123,15 @@ class BusInterfaces:
                     device_hier_paths[name] = hier_path
                 else:
                     device_hier_paths[name] = 'u_reg'
+            interface_list.append({'name': name,
+                                   'protocol': BusProtocol(protocol),
+                                   'is_host': direction=='host'})
 
         if not (has_unnamed_device or named_devices):
             raise ValueError('No device interface at ' + where)
 
         return BusInterfaces(has_unnamed_host, named_hosts, host_async,
-                             has_unnamed_device, named_devices,
+                             has_unnamed_device, named_devices, interface_list,
                              device_async, device_hier_paths)
 
     def has_host(self) -> bool:
diff --git a/fpv_csr.sv.tpl b/fpv_csr.sv.tpl
index 484a67d93..148ef4674 100644
--- a/fpv_csr.sv.tpl
+++ b/fpv_csr.sv.tpl
@@ -12,6 +12,7 @@
   from topgen import lib
 
   lblock = block.name.lower()
+  use_reg_iface = any([interface['protocol'] == BusProtocol.REG_IFACE and not interace['is_host'] for interface in block.bus_interfaces.interface_list])
 
   # This template shouldn't be instantiated if the device interface
   # doesn't actually have any registers.
@@ -20,7 +21,11 @@
 %>\
 <%def name="construct_classes(block)">\
 
+% if use_reg_iface:
+`include "common_cells/assertions.svh"
+% else:
 `include "prim_assert.sv"
+% endif
 
 `ifndef FPV_ON
   `define REGWEN_PATH tb.dut.${reg_block_path}
diff --git a/reg_top.sv.tpl b/reg_top.sv.tpl
index 95db83b4f..4a49ba546 100644
--- a/reg_top.sv.tpl
+++ b/reg_top.sv.tpl
@@ -10,6 +10,8 @@
   from reggen.register import Register
   from reggen.multi_register import MultiRegister
   from reggen.bits import Bits
+  from reggen.ip_block import IpBlock
+  from reggen.bus_interfaces import BusProtocol
 
   alias_impl = "_" + block.alias_impl if block.alias_impl else ""
 
@@ -45,6 +47,11 @@
                 rb.windows[0].offset != 0 or
                 rb.windows[0].size_in_bytes != (1 << addr_width)))
 
+  # Check if the interface protocol is reg_interface
+  use_reg_iface = any([interface['protocol'] == BusProtocol.REG_IFACE and not interface['is_host'] for interface in block.bus_interfaces.interface_list])
+  reg_intf_req = "reg_req_t"
+  reg_intf_rsp = "reg_rsp_t"
+ 
 
   common_data_intg_gen = 0 if rb.has_data_intg_passthru else 1
   adapt_data_intg_gen = 1 if rb.has_data_intg_passthru else 0
@@ -113,9 +120,28 @@
         finst_names[field] = (fsig_name, finst_name)
 
 %>
+
+% if use_reg_iface:
+`include "common_cells/assertions.svh"
+% else:
 `include "prim_assert.sv"
+% endif
 
-module ${mod_name} (
+module ${mod_name} \
+% if use_reg_iface:
+#(
+    parameter type reg_req_t = logic,
+    parameter type reg_rsp_t = logic,
+    parameter int AW = ${addr_width}
+) \
+% else:
+    % if needs_aw:
+#(
+    parameter int AW = ${addr_width}
+) \
+    % endif
+% endif
+(
   input clk_i,
   input rst_ni,
 % if rb.has_internal_shadowed_reg():
@@ -125,13 +151,23 @@ module ${mod_name} (
   input ${clock.clock},
   input ${clock.reset},
 % endfor
+% if use_reg_iface:
+  input  ${reg_intf_req} reg_req_i,
+  output ${reg_intf_rsp} reg_rsp_o,
+% else:
   input  tlul_pkg::tl_h2d_t tl_i,
   output tlul_pkg::tl_d2h_t tl_o,
+% endif
 % if num_wins != 0:
 
   // Output port for window
+% if use_reg_iface:
+  output ${reg_intf_req} [${num_wins}-1:0] reg_req_win_o,
+  input  ${reg_intf_rsp} [${num_wins}-1:0] reg_rsp_win_i,
+% else:
   output tlul_pkg::tl_h2d_t tl_win_o${win_array_decl},
   input  tlul_pkg::tl_d2h_t tl_win_i${win_array_decl},
+% endif
 
 % endif
   // To HW
@@ -147,8 +183,10 @@ module ${mod_name} (
   output logic shadowed_update_err_o,
 
 %endif
+% if not use_reg_iface:
   // Integrity check errors
   output logic intg_err_o,
+% endif
 
   // Config
   input devmode_i // If 1, explicit error return for unmapped register access
@@ -156,9 +194,6 @@ module ${mod_name} (
 
   import ${lblock}${alias_impl}_reg_pkg::* ;
 
-% if needs_aw:
-  localparam int AW = ${addr_width};
-% endif
 % if rb.all_regs:
   localparam int DW = ${block.regwidth};
   localparam int DBW = DW/8;                    // Byte Width
@@ -177,9 +212,15 @@ module ${mod_name} (
   logic [DW-1:0] reg_rdata_next;
   logic reg_busy;
 
+% if use_reg_iface:
+  // Below register interface can be changed
+  reg_req_t  reg_intf_req;
+  reg_rsp_t  reg_intf_rsp;
+% else:
   tlul_pkg::tl_h2d_t tl_reg_h2d;
   tlul_pkg::tl_d2h_t tl_reg_d2h;
 % endif
+% endif
 
 ## The clock and reset inputs aren't used if this device interface has no
 ## registers, only one window and isn't marked asynchronous. In that case, add
@@ -217,6 +258,7 @@ module ${mod_name} (
   );
 % endif
 
+% if not use_reg_iface:
 % if rb.all_regs:
   // incoming payload check
   logic intg_err;
@@ -280,23 +322,63 @@ module ${mod_name} (
     .tl_i(tl_o_pre),
     .tl_o(${tl_d2h_expr})
   );
+% endif
 
 % if num_dsp <= 1:
   ## Either no windows (and just registers) or no registers and only
   ## one window.
   % if num_wins == 0:
+    % if use_reg_iface:
+  assign reg_intf_req = reg_req_i;
+  assign reg_rsp_o = reg_intf_rsp;
+    % else:
   assign tl_reg_h2d = ${tl_h2d_expr};
   assign tl_o_pre   = tl_reg_d2h;
+    % endif
   % else:
+    % if use_reg_iface:
+  assign reg_req_win_o = reg_req_i;
+  assign reg_rsp_o = reg_rsp_win_i
+    % else:
   assign tl_win_o = ${tl_h2d_expr};
   assign tl_o_pre = tl_win_i;
+    % endif
   % endif
 % else:
+  logic [${num_wins_width-1}:0] reg_steer;
+
+  % if use_reg_iface:
+  ${reg_intf_req} [${num_dsp}-1:0] reg_intf_demux_req;
+  ${reg_intf_rsp} [${num_dsp}-1:0] reg_intf_demux_rsp;
+
+  // demux connection
+  assign reg_intf_req = reg_intf_demux_req[${num_wins}];
+  assign reg_intf_demux_rsp[${num_wins}] = reg_intf_rsp;
+
+    % for i,t in enumerate(block.wins):
+  assign reg_req_win_o[${i}] = reg_intf_demux_req[${i}];
+  assign reg_intf_demux_rsp[${i}] = reg_rsp_win_i[${i}];
+    % endfor
+
+  // Create Socket_1n
+  reg_demux #(
+    .NoPorts  (${num_dsp}),
+    .req_t    (${reg_intf_req}),
+    .rsp_t    (${reg_intf_rsp})
+  ) i_reg_demux (
+    .clk_i,
+    .rst_ni,
+    .in_req_i (reg_req_i),
+    .in_rsp_o (reg_rsp_o),
+    .out_req_o (reg_intf_demux_req),
+    .out_rsp_i (reg_intf_demux_rsp),
+    .in_select_i (reg_steer)
+  );
+
+  % else:
   tlul_pkg::tl_h2d_t tl_socket_h2d [${num_dsp}];
   tlul_pkg::tl_d2h_t tl_socket_d2h [${num_dsp}];
 
-  logic [${steer_msb}:0] reg_steer;
-
   // socket_1n connection
   % if rb.all_regs:
   assign tl_reg_h2d = tl_socket_h2d[${num_wins}];
@@ -344,6 +426,7 @@ module ${mod_name} (
     .tl_d_i (tl_socket_d2h),
     .dev_select_i (reg_steer)
   );
+% endif
 
   // Create steering logic
   always_comb begin
@@ -361,14 +444,26 @@ module ${mod_name} (
         // Default set to register
         ${steer_width}'d${num_dsp-1};
 
+  % if not use_reg_iface:
     // Override this in case of an integrity error
     if (intg_err) begin
       reg_steer = ${steer_width}'d${num_dsp-1};
     end
+  % endif
   end
 % endif
 % if rb.all_regs:
 
+% if use_reg_iface:
+  assign reg_we = reg_intf_req.valid & reg_intf_req.write;
+  assign reg_re = reg_intf_req.valid & ~reg_intf_req.write;
+  assign reg_addr = reg_intf_req.addr;
+  assign reg_wdata = reg_intf_req.wdata;
+  assign reg_be = reg_intf_req.wstrb;
+  assign reg_intf_rsp.rdata = reg_rdata;
+  assign reg_intf_rsp.error = reg_error;
+  assign reg_intf_rsp.ready = 1'b1;
+% else:
   tlul_adapter_reg #(
     .RegAw(AW),
     .RegDw(DW),
@@ -392,6 +487,7 @@ module ${mod_name} (
     .rdata_i (reg_rdata),
     .error_i (reg_error)
   );
+% endif
 
   // cdc oversampling signals
 
@@ -404,7 +500,11 @@ module ${mod_name} (
 
   % endif
   assign reg_rdata = reg_rdata_next ;
+  % if use_reg_iface:
+  assign reg_error = (devmode_i & addrmiss) | wr_err;
+  % else:
   assign reg_error = (devmode_i & addrmiss) | wr_err | intg_err;
+  % endif
 
   // Define SW related signals
   // Format: <reg>_<field>_{wd|we|qs}
@@ -818,16 +918,17 @@ ${rdata_gen(f, r.name.lower() + "_" + f.name.lower())}\
 % if rb.all_regs:
 
   // Assertions for Register Interface
+  % if not use_reg_iface:
   `ASSERT_PULSE(wePulse, reg_we, ${reg_clk_expr}, !${reg_rst_expr})
   `ASSERT_PULSE(rePulse, reg_re, ${reg_clk_expr}, !${reg_rst_expr})
 
   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, ${reg_clk_expr}, !${reg_rst_expr})
 
-  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), ${reg_clk_expr}, !${reg_rst_expr})
-
   // this is formulated as an assumption such that the FPV testbenches do disprove this
   // property by mistake
   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
+  % endif
+  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), ${reg_clk_expr}, !${reg_rst_expr})
 
 % endif
 endmodule
-- 
2.31.1

